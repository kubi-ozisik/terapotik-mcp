
generator client {
  provider      = "prisma-client-js"
  // next line is needed for build
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider  = "mongodb"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String         @id @default(auto()) @map("_id") @db.ObjectId
  name          String?
  email         String?        @unique
  emailVerified DateTime?
    password              String?
  image         String?
  authId        String?        @unique
  accounts      Account[]
  sessions      Session[]
  serviceTokens ServiceToken[]
  isTwoFactorEnabled    Boolean                @default(false)
  twoFactorConfirmation TwoFactorConfirmation?
  chats              Chat[]               @relation("UserChats")
  chatDocuments      ChatDocument[]       @relation("UserChatDocuments")
  role                  UserRole               @default(GUEST)
    // one-to-one
  profile      Profile?
}

enum UserRole {
  GUEST
  EXPERIMENTAL_USER
  ORGANIZATION_OWNER
  EXPERIMENTAL_ORGANIZATION_OWNER
  ADMIN
  MODERATOR
  USER
  DESIGNER
  CUSTOMER
}


model Profile {
  id              String  @id @default(auto()) @map("_id") @db.ObjectId
  preferredLayout String?
  name            String?
  firstName       String?
  lastName        String?
  image           String?
  bio             String?
  email           String?
  subdomain       String
  timezone        String?
  language        String?

  jobTitle       String?
  whatsapp       String?
  telegram       String?
  phone          String?
  twitterUrl     String?
  linkedInUrl    String?
  companyLogoUrl String?
  coverPhotoUrl  String?
  companyName    String?
  department     String?
  facebookUrl    String?
  youtubeUrl     String?
  snapchatUrl    String?
  discord        String?
  qrCodeId       String? // there will be relation 

  stripeId       String?
  subscriptionId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.ObjectId

  @@unique([userId])
}

model TwoFactorToken {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}

model VerificationToken {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model ServiceToken {
  id           String    @id @default(auto()) @map("_id") @db.ObjectId
  userId       String    @db.ObjectId
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  service      String // "google" or "atlassian"
  accessToken  String
  refreshToken String?
  expiresAt    DateTime?
  scope        String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([userId, service])
}

model PasswordResetToken {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

// AI Chat Module Models
model Chat {
  id         String @id @default(auto()) @map("_id") @db.ObjectId
  userId     String @db.ObjectId
  user       User   @relation("UserChats", fields: [userId], references: [id], onDelete: Cascade)
  title      String
  visibility String @default("private") // "private" | "public"
  module     String @default("general") // "test-chat" | "booking-agent" | "kanban" | "general"

  messages  ChatMessage[]
  votes     ChatVote[]
  documents ChatDocument[]
  streams   ChatStream[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([createdAt])
  @@index([module])
}

model ChatMessage {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  chatId      String @db.ObjectId
  chat        Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  role        String // "user" | "assistant" | "system" | "tool"
  parts       Json // UIMessagePart[] Message parts (text, tool calls, etc.)
  metadata    Json? // UIMessageMetadata

  attachments Json? // File attachments, images, etc.
  votes ChatVote[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([chatId])
  @@index([createdAt])
}

model ChatVote {
  id        String      @id @default(auto()) @map("_id") @db.ObjectId
  chatId    String      @db.ObjectId
  chat      Chat        @relation(fields: [chatId], references: [id], onDelete: Cascade)
  messageId String      @db.ObjectId
  message   ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  isUpvoted Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([messageId])
  @@index([chatId])
}

model ChatDocument {
  id           String  @id @default(auto()) @map("_id") @db.ObjectId
  toolResultId String // Store the tool's generated ID here
  title        String
  kind         String // "text" | "code" | "image" | "sheet"
  content      String?
  userId       String  @db.ObjectId
  user         User    @relation("UserChatDocuments", fields: [userId], references: [id], onDelete: Cascade)
  chatId       String  @db.ObjectId
  chat         Chat    @relation(fields: [chatId], references: [id], onDelete: Cascade)

  suggestions ChatSuggestion[]

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([chatId])
  @@index([toolResultId]) // Index on tool result ID for querying
  @@index([createdAt])
}


model ChatSuggestion {
  id                String       @id @default(auto()) @map("_id") @db.ObjectId
  documentId        String       @db.ObjectId
  document          ChatDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentCreatedAt DateTime
  originalText      String
  suggestedText     String
  description       String?
  isResolved        Boolean      @default(false)
  userId            String       @db.ObjectId

  createdAt DateTime @default(now())

  @@index([documentId])
}

model ChatStream {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  chatId String @db.ObjectId
  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([chatId])
}